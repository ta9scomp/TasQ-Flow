# ä»˜ç®‹ã‚¿ãƒ–ä¸€è¦§ã®èƒŒæ™¯ä½œæˆ å­¦ç¿’ã‚¬ã‚¤ãƒ‰

**å¯¾è±¡**: Reactãƒ»CSSåŸºç¤ã‚’å­¦ã‚“ã é–‹ç™ºè€…  
**é›£æ˜“åº¦**: â­â­â­â˜†â˜†ï¼ˆä¸­ç´šï¼‰  
**å­¦ç¿’æ™‚é–“**: ç´„3-4æ™‚é–“

---

## ğŸ“š ã“ã®ã‚¬ã‚¤ãƒ‰ã§å­¦ã¹ã‚‹ã“ã¨

- ä»˜ç®‹é¢¨UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®è¨­è¨ˆã¨å®Ÿè£…
- ã‚¿ãƒ–ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã§ã®ç¾ã—ã„èƒŒæ™¯ãƒ‡ã‚¶ã‚¤ãƒ³
- å®Ÿç”¨çš„ãªä»˜ç®‹æ©Ÿèƒ½ï¼ˆä½œæˆã€ç·¨é›†ã€å‰Šé™¤ã€ç§»å‹•ï¼‰
- ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½ã®å®Ÿè£…
- ä»˜ç®‹ã®è‰²åˆ†ã‘ã¨ã‚«ãƒ†ã‚´ãƒªãƒ¼ç®¡ç†
- ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œã®ä»˜ç®‹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ

---

## ğŸ¯ å®Œæˆã‚¤ãƒ¡ãƒ¼ã‚¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ—’ï¸ ä»˜ç®‹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ                     [+ æ–°è¦è¿½åŠ ] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [ğŸ“‹ ã™ã¹ã¦] [ğŸ”´ é‡è¦] [ğŸŸ¡ é€šå¸¸] [ğŸŸ¢ å®Œäº†] [âš™ï¸ è¨­å®š] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ ğŸ”´ é‡è¦  â”‚  â”‚ ğŸŸ¡ ã‚¢ã‚¤ãƒ‡ã‚¢â”‚  â”‚ ğŸŸ¢ å®Œäº†æ¸ˆã¿â”‚             â”‚
â”‚  â”‚ UIä¿®æ­£   â”‚  â”‚ æ–°æ©Ÿèƒ½æ¤œè¨ â”‚  â”‚ ãƒã‚°ä¿®æ­£   â”‚             â”‚
â”‚  â”‚ å„ªå…ˆåº¦:é«˜â”‚  â”‚ æ˜æ—¥ã¾ã§   â”‚  â”‚ âœ“ å®Œäº†    â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚  â”‚ ğŸŸ¦ ãƒ¡ãƒ¢  â”‚  â”‚ ğŸŸ£ è³ªå•   â”‚                          â”‚
â”‚  â”‚ ä¼šè­°å†…å®¹ â”‚  â”‚ æŠ€è¡“ç›¸è«‡   â”‚                          â”‚
â”‚  â”‚ 2æ™‚é–“å‰  â”‚  â”‚ ãƒ¬ãƒ“ãƒ¥ãƒ¼å¾…ã¡â”‚                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ—ï¸ Step 1: åŸºæœ¬ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæ§‹é€ ã®è¨­è¨ˆ

### 1.1 ä»˜ç®‹ãƒ‡ãƒ¼ã‚¿å‹ã®å®šç¾©

```typescript
// types/stickyNote.ts
export interface StickyNote {
  id: string;
  title: string;
  content: string;
  color: 'red' | 'yellow' | 'green' | 'blue' | 'purple' | 'orange';
  category: 'important' | 'normal' | 'completed' | 'memo' | 'question';
  position: {
    x: number;
    y: number;
  };
  size: {
    width: number;
    height: number;
  };
  priority: 'high' | 'medium' | 'low';
  createdAt: Date;
  updatedAt: Date;
  dueDate?: Date;
  tags: string[];
  isCompleted: boolean;
}

export interface StickyNotesFilter {
  category?: string;
  color?: string;
  priority?: string;
  searchQuery?: string;
}
```

### 1.2 ä»˜ç®‹ã‚¹ãƒˆã‚¢ã®è¨­è¨ˆ

```typescript
// stores/useStickyNotesStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { StickyNote, StickyNotesFilter } from '../types/stickyNote';

interface StickyNotesState {
  notes: StickyNote[];
  selectedNoteId: string | null;
  filter: StickyNotesFilter;
  draggedNote: StickyNote | null;
  isCreateDialogOpen: boolean;
  isEditDialogOpen: boolean;
}

interface StickyNotesActions {
  // CRUDæ“ä½œ
  addNote: (note: Omit<StickyNote, 'id' | 'createdAt' | 'updatedAt'>) => void;
  updateNote: (id: string, updates: Partial<StickyNote>) => void;
  deleteNote: (id: string) => void;
  
  // é¸æŠãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
  selectNote: (id: string | null) => void;
  setFilter: (filter: Partial<StickyNotesFilter>) => void;
  clearFilter: () => void;
  
  // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
  setDraggedNote: (note: StickyNote | null) => void;
  moveNote: (id: string, newPosition: { x: number; y: number }) => void;
  
  // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°åˆ¶å¾¡
  openCreateDialog: () => void;
  closeCreateDialog: () => void;
  openEditDialog: (noteId: string) => void;
  closeEditDialog: () => void;
  
  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
  getFilteredNotes: () => StickyNote[];
  getNotesByCategory: (category: string) => StickyNote[];
  searchNotes: (query: string) => StickyNote[];
}

export const useStickyNotesStore = create<StickyNotesState & StickyNotesActions>()(
  persist(
    (set, get) => ({
      // åˆæœŸçŠ¶æ…‹
      notes: [],
      selectedNoteId: null,
      filter: {},
      draggedNote: null,
      isCreateDialogOpen: false,
      isEditDialogOpen: false,
      
      // CRUDæ“ä½œ
      addNote: (noteData) => {
        const newNote: StickyNote = {
          id: `note-${Date.now()}`,
          ...noteData,
          createdAt: new Date(),
          updatedAt: new Date()
        };
        
        set((state) => ({
          notes: [...state.notes, newNote]
        }));
      },
      
      updateNote: (id, updates) => {
        set((state) => ({
          notes: state.notes.map(note =>
            note.id === id
              ? { ...note, ...updates, updatedAt: new Date() }
              : note
          )
        }));
      },
      
      deleteNote: (id) => {
        set((state) => ({
          notes: state.notes.filter(note => note.id !== id),
          selectedNoteId: state.selectedNoteId === id ? null : state.selectedNoteId
        }));
      },
      
      // é¸æŠãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
      selectNote: (id) => set({ selectedNoteId: id }),
      
      setFilter: (newFilter) => {
        set((state) => ({
          filter: { ...state.filter, ...newFilter }
        }));
      },
      
      clearFilter: () => set({ filter: {} }),
      
      // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
      setDraggedNote: (note) => set({ draggedNote: note }),
      
      moveNote: (id, newPosition) => {
        set((state) => ({
          notes: state.notes.map(note =>
            note.id === id
              ? { ...note, position: newPosition, updatedAt: new Date() }
              : note
          )
        }));
      },
      
      // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°åˆ¶å¾¡
      openCreateDialog: () => set({ isCreateDialogOpen: true }),
      closeCreateDialog: () => set({ isCreateDialogOpen: false }),
      openEditDialog: (noteId) => {
        set({ 
          isEditDialogOpen: true, 
          selectedNoteId: noteId 
        });
      },
      closeEditDialog: () => set({ isEditDialogOpen: false }),
      
      // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
      getFilteredNotes: () => {
        const { notes, filter } = get();
        let filteredNotes = [...notes];
        
        if (filter.category) {
          filteredNotes = filteredNotes.filter(note => note.category === filter.category);
        }
        
        if (filter.color) {
          filteredNotes = filteredNotes.filter(note => note.color === filter.color);
        }
        
        if (filter.priority) {
          filteredNotes = filteredNotes.filter(note => note.priority === filter.priority);
        }
        
        if (filter.searchQuery) {
          const query = filter.searchQuery.toLowerCase();
          filteredNotes = filteredNotes.filter(note =>
            note.title.toLowerCase().includes(query) ||
            note.content.toLowerCase().includes(query) ||
            note.tags.some(tag => tag.toLowerCase().includes(query))
          );
        }
        
        return filteredNotes;
      },
      
      getNotesByCategory: (category) => {
        const { notes } = get();
        return notes.filter(note => note.category === category);
      },
      
      searchNotes: (query) => {
        const { notes } = get();
        const searchQuery = query.toLowerCase();
        
        return notes.filter(note =>
          note.title.toLowerCase().includes(searchQuery) ||
          note.content.toLowerCase().includes(searchQuery) ||
          note.tags.some(tag => tag.toLowerCase().includes(searchQuery))
        );
      }
    }),
    {
      name: 'sticky-notes-storage',
      partialize: (state) => ({
        notes: state.notes,
        filter: state.filter
      })
    }
  )
);
```

### 1.3 ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆã®å®šç¾©

```typescript
// utils/stickyNoteColors.ts
export const STICKY_COLORS = {
  red: {
    background: 'linear-gradient(135deg, #ffeb3b 0%, #ffc107 50%, #ff9800 100%)',
    border: '#ff6b6b',
    shadow: 'rgba(255, 107, 107, 0.3)',
    text: '#2c3e50'
  },
  yellow: {
    background: 'linear-gradient(135deg, #fff9c4 0%, #fff176 50%, #ffeb3b 100%)',
    border: '#fbc02d',
    shadow: 'rgba(251, 192, 45, 0.3)',
    text: '#2c3e50'
  },
  green: {
    background: 'linear-gradient(135deg, #c8e6c9 0%, #81c784 50%, #4caf50 100%)',
    border: '#4caf50',
    shadow: 'rgba(76, 175, 80, 0.3)',
    text: '#2c3e50'
  },
  blue: {
    background: 'linear-gradient(135deg, #e3f2fd 0%, #90caf9 50%, #2196f3 100%)',
    border: '#2196f3',
    shadow: 'rgba(33, 150, 243, 0.3)',
    text: '#2c3e50'
  },
  purple: {
    background: 'linear-gradient(135deg, #f3e5f5 0%, #ce93d8 50%, #9c27b0 100%)',
    border: '#9c27b0',
    shadow: 'rgba(156, 39, 176, 0.3)',
    text: '#ffffff'
  },
  orange: {
    background: 'linear-gradient(135deg, #fff3e0 0%, #ffb74d 50%, #ff9800 100%)',
    border: '#ff9800',
    shadow: 'rgba(255, 152, 0, 0.3)',
    text: '#2c3e50'
  }
} as const;

export const CATEGORY_ICONS = {
  important: 'ğŸ”´',
  normal: 'ğŸŸ¡',
  completed: 'ğŸŸ¢',
  memo: 'ğŸŸ¦',
  question: 'ğŸŸ£'
} as const;

export const PRIORITY_COLORS = {
  high: '#f44336',
  medium: '#ff9800',
  low: '#4caf50'
} as const;
```

---

## ğŸ—ï¸ Step 2: ãƒ¡ã‚¤ãƒ³ä»˜ç®‹ãƒšãƒ¼ã‚¸ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

### 2.1 ä»˜ç®‹ãƒšãƒ¼ã‚¸ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ

```typescript
// components/StickyNotes/StickyNotesPage.tsx
import React, { useState } from 'react';
import {
  Box,
  Grid,
  Typography,
  Button,
  Tabs,
  Tab,
  Paper,
  Container
} from '@mui/material';
import { Add as AddIcon } from '@mui/icons-material';
import { useStickyNotesStore } from '../../stores/useStickyNotesStore';
import { StickyNoteGrid } from './StickyNoteGrid';
import { StickyNoteFilters } from './StickyNoteFilters';
import { CreateNoteDialog } from './CreateNoteDialog';
import { EditNoteDialog } from './EditNoteDialog';
import { CATEGORY_ICONS } from '../../utils/stickyNoteColors';

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel({ children, value, index }: TabPanelProps) {
  return (
    <div hidden={value !== index} style={{ height: '100%' }}>
      {value === index && children}
    </div>
  );
}

export const StickyNotesPage: React.FC = () => {
  const [tabValue, setTabValue] = useState(0);
  const {
    openCreateDialog,
    isCreateDialogOpen,
    isEditDialogOpen,
    getNotesByCategory,
    filter,
    setFilter
  } = useStickyNotesStore();

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
    
    // ã‚¿ãƒ–ã«å¿œã˜ã¦ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’è¨­å®š
    const categories = ['', 'important', 'normal', 'completed', 'memo', 'question'];
    const selectedCategory = categories[newValue];
    
    if (selectedCategory) {
      setFilter({ category: selectedCategory });
    } else {
      setFilter({ category: undefined });
    }
  };

  const getCategoryCount = (category: string) => {
    return getNotesByCategory(category).length;
  };

  return (
    <Container maxWidth="xl" sx={{ height: '100vh', py: 2 }}>
      {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
        <Typography variant="h4" component="h1" sx={{ fontWeight: 'bold' }}>
          ğŸ—’ï¸ ä»˜ç®‹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
        </Typography>
        <Button
          variant="contained"
          startIcon={<AddIcon />}
          onClick={openCreateDialog}
          sx={{
            borderRadius: 2,
            textTransform: 'none',
            fontSize: '1rem',
            fontWeight: 'bold'
          }}
        >
          æ–°è¦è¿½åŠ 
        </Button>
      </Box>

      {/* ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ */}
      <StickyNoteFilters />

      {/* ã‚¿ãƒ–ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ */}
      <Paper elevation={2} sx={{ mb: 2 }}>
        <Tabs
          value={tabValue}
          onChange={handleTabChange}
          variant="scrollable"
          scrollButtons="auto"
          sx={{
            borderBottom: 1,
            borderColor: 'divider',
            '& .MuiTab-root': {
              textTransform: 'none',
              fontWeight: 'bold',
              fontSize: '1rem'
            }
          }}
        >
          <Tab 
            label={`ğŸ“‹ ã™ã¹ã¦ (${getNotesByCategory('').length})`}
            sx={{ minWidth: 120 }}
          />
          <Tab 
            label={`ğŸ”´ é‡è¦ (${getCategoryCount('important')})`}
            sx={{ minWidth: 120 }}
          />
          <Tab 
            label={`ğŸŸ¡ é€šå¸¸ (${getCategoryCount('normal')})`}
            sx={{ minWidth: 120 }}
          />
          <Tab 
            label={`ğŸŸ¢ å®Œäº† (${getCategoryCount('completed')})`}
            sx={{ minWidth: 120 }}
          />
          <Tab 
            label={`ğŸŸ¦ ãƒ¡ãƒ¢ (${getCategoryCount('memo')})`}
            sx={{ minWidth: 120 }}
          />
          <Tab 
            label={`ğŸŸ£ è³ªå• (${getCategoryCount('question')})`}
            sx={{ minWidth: 120 }}
          />
        </Tabs>
      </Paper>

      {/* ã‚¿ãƒ–ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */}
      <Box sx={{ flexGrow: 1, height: 'calc(100vh - 250px)' }}>
        <TabPanel value={tabValue} index={0}>
          <StickyNoteGrid showAll />
        </TabPanel>
        <TabPanel value={tabValue} index={1}>
          <StickyNoteGrid category="important" />
        </TabPanel>
        <TabPanel value={tabValue} index={2}>
          <StickyNoteGrid category="normal" />
        </TabPanel>
        <TabPanel value={tabValue} index={3}>
          <StickyNoteGrid category="completed" />
        </TabPanel>
        <TabPanel value={tabValue} index={4}>
          <StickyNoteGrid category="memo" />
        </TabPanel>
        <TabPanel value={tabValue} index={5}>
          <StickyNoteGrid category="question" />
        </TabPanel>
      </Box>

      {/* ãƒ€ã‚¤ã‚¢ãƒ­ã‚° */}
      <CreateNoteDialog />
      <EditNoteDialog />
    </Container>
  );
};
```

### 2.2 ä»˜ç®‹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```typescript
// components/StickyNotes/StickyNoteFilters.tsx
import React from 'react';
import {
  Box,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Chip,
  IconButton,
  Paper
} from '@mui/material';
import {
  Search as SearchIcon,
  Clear as ClearIcon,
  FilterList as FilterIcon
} from '@mui/icons-material';
import { useStickyNotesStore } from '../../stores/useStickyNotesStore';
import { STICKY_COLORS, PRIORITY_COLORS } from '../../utils/stickyNoteColors';

export const StickyNoteFilters: React.FC = () => {
  const { filter, setFilter, clearFilter } = useStickyNotesStore();

  const handleSearchChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setFilter({ searchQuery: event.target.value });
  };

  const handleColorChange = (event: any) => {
    setFilter({ color: event.target.value || undefined });
  };

  const handlePriorityChange = (event: any) => {
    setFilter({ priority: event.target.value || undefined });
  };

  const hasActiveFilters = Boolean(
    filter.searchQuery || filter.color || filter.priority
  );

  return (
    <Paper elevation={1} sx={{ p: 2, mb: 2 }}>
      <Box display="flex" alignItems="center" gap={2} flexWrap="wrap">
        {/* æ¤œç´¢ãƒœãƒƒã‚¯ã‚¹ */}
        <TextField
          placeholder="ä»˜ç®‹ã‚’æ¤œç´¢..."
          value={filter.searchQuery || ''}
          onChange={handleSearchChange}
          InputProps={{
            startAdornment: <SearchIcon sx={{ mr: 1, color: 'action.active' }} />
          }}
          sx={{ minWidth: 250 }}
          size="small"
        />

        {/* ã‚«ãƒ©ãƒ¼ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ */}
        <FormControl size="small" sx={{ minWidth: 120 }}>
          <InputLabel>è‰²</InputLabel>
          <Select
            value={filter.color || ''}
            onChange={handleColorChange}
            label="è‰²"
          >
            <MenuItem value="">ã™ã¹ã¦</MenuItem>
            {Object.entries(STICKY_COLORS).map(([color, colorConfig]) => (
              <MenuItem key={color} value={color}>
                <Box display="flex" alignItems="center" gap={1}>
                  <Box
                    sx={{
                      width: 16,
                      height: 16,
                      borderRadius: '50%',
                      background: colorConfig.background,
                      border: `1px solid ${colorConfig.border}`
                    }}
                  />
                  {color}
                </Box>
              </MenuItem>
            ))}
          </Select>
        </FormControl>

        {/* å„ªå…ˆåº¦ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ */}
        <FormControl size="small" sx={{ minWidth: 120 }}>
          <InputLabel>å„ªå…ˆåº¦</InputLabel>
          <Select
            value={filter.priority || ''}
            onChange={handlePriorityChange}
            label="å„ªå…ˆåº¦"
          >
            <MenuItem value="">ã™ã¹ã¦</MenuItem>
            <MenuItem value="high">
              <Box display="flex" alignItems="center" gap={1}>
                <Box
                  sx={{
                    width: 8,
                    height: 8,
                    borderRadius: '50%',
                    backgroundColor: PRIORITY_COLORS.high
                  }}
                />
                é«˜
              </Box>
            </MenuItem>
            <MenuItem value="medium">
              <Box display="flex" alignItems="center" gap={1}>
                <Box
                  sx={{
                    width: 8,
                    height: 8,
                    borderRadius: '50%',
                    backgroundColor: PRIORITY_COLORS.medium
                  }}
                />
                ä¸­
              </Box>
            </MenuItem>
            <MenuItem value="low">
              <Box display="flex" alignItems="center" gap={1}>
                <Box
                  sx={{
                    width: 8,
                    height: 8,
                    borderRadius: '50%',
                    backgroundColor: PRIORITY_COLORS.low
                  }}
                />
                ä½
              </Box>
            </MenuItem>
          </Select>
        </FormControl>

        {/* ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ */}
        {hasActiveFilters && (
          <IconButton
            onClick={clearFilter}
            color="secondary"
            size="small"
            sx={{
              backgroundColor: 'action.selected',
              '&:hover': {
                backgroundColor: 'action.hover'
              }
            }}
          >
            <ClearIcon />
          </IconButton>
        )}
      </Box>

      {/* ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®è¡¨ç¤º */}
      {hasActiveFilters && (
        <Box mt={1} display="flex" gap={1} flexWrap="wrap">
          {filter.searchQuery && (
            <Chip
              label={`æ¤œç´¢: ${filter.searchQuery}`}
              onDelete={() => setFilter({ searchQuery: undefined })}
              size="small"
              color="primary"
              variant="outlined"
            />
          )}
          {filter.color && (
            <Chip
              label={`è‰²: ${filter.color}`}
              onDelete={() => setFilter({ color: undefined })}
              size="small"
              color="secondary"
              variant="outlined"
            />
          )}
          {filter.priority && (
            <Chip
              label={`å„ªå…ˆåº¦: ${filter.priority}`}
              onDelete={() => setFilter({ priority: undefined })}
              size="small"
              color="info"
              variant="outlined"
            />
          )}
        </Box>
      )}
    </Paper>
  );
};
```

---

## ğŸ—ï¸ Step 3: ä»˜ç®‹è¡¨ç¤ºã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

### 3.1 ä»˜ç®‹ã‚°ãƒªãƒƒãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```typescript
// components/StickyNotes/StickyNoteGrid.tsx
import React, { useMemo } from 'react';
import {
  Box,
  Grid,
  Typography,
  Paper,
  Zoom
} from '@mui/material';
import { useStickyNotesStore } from '../../stores/useStickyNotesStore';
import { StickyNoteCard } from './StickyNoteCard';
import { EmptyState } from './EmptyState';

interface StickyNoteGridProps {
  category?: string;
  showAll?: boolean;
}

export const StickyNoteGrid: React.FC<StickyNoteGridProps> = ({ 
  category, 
  showAll = false 
}) => {
  const { getFilteredNotes, getNotesByCategory } = useStickyNotesStore();

  const notes = useMemo(() => {
    if (showAll) {
      return getFilteredNotes();
    }
    if (category) {
      return getNotesByCategory(category);
    }
    return [];
  }, [showAll, category, getFilteredNotes, getNotesByCategory]);

  if (notes.length === 0) {
    return (
      <EmptyState 
        message={category ? `${category}ã‚«ãƒ†ã‚´ãƒªã®ä»˜ç®‹ãŒã‚ã‚Šã¾ã›ã‚“` : 'ä»˜ç®‹ãŒã‚ã‚Šã¾ã›ã‚“'}
        category={category}
      />
    );
  }

  return (
    <Box sx={{ height: '100%', overflow: 'auto', p: 1 }}>
      <Grid container spacing={2}>
        {notes.map((note, index) => (
          <Grid item xs={12} sm={6} md={4} lg={3} key={note.id}>
            <Zoom in timeout={200 + index * 50}>
              <div>
                <StickyNoteCard note={note} />
              </div>
            </Zoom>
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};
```

### 3.2 ä»˜ç®‹ã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```typescript
// components/StickyNotes/StickyNoteCard.tsx
import React, { useState } from 'react';
import {
  Card,
  CardContent,
  Typography,
  Box,
  IconButton,
  Chip,
  Tooltip,
  Menu,
  MenuItem,
  ListItemIcon,
  Fade
} from '@mui/material';
import {
  MoreVert as MoreIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  DragIndicator as DragIcon,
  Schedule as ScheduleIcon,
  Flag as FlagIcon
} from '@mui/icons-material';
import { StickyNote } from '../../types/stickyNote';
import { useStickyNotesStore } from '../../stores/useStickyNotesStore';
import { STICKY_COLORS, CATEGORY_ICONS, PRIORITY_COLORS } from '../../utils/stickyNoteColors';
import { formatDistanceToNow } from 'date-fns';
import { ja } from 'date-fns/locale';

interface StickyNoteCardProps {
  note: StickyNote;
}

export const StickyNoteCard: React.FC<StickyNoteCardProps> = ({ note }) => {
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const [isHovered, setIsHovered] = useState(false);
  const { openEditDialog, deleteNote, selectNote } = useStickyNotesStore();

  const colorConfig = STICKY_COLORS[note.color];
  const categoryIcon = CATEGORY_ICONS[note.category];
  const priorityColor = PRIORITY_COLORS[note.priority];

  const handleMenuClick = (event: React.MouseEvent<HTMLElement>) => {
    event.stopPropagation();
    setAnchorEl(event.currentTarget);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
  };

  const handleEdit = () => {
    openEditDialog(note.id);
    handleMenuClose();
  };

  const handleDelete = () => {
    if (window.confirm('ã“ã®ä»˜ç®‹ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
      deleteNote(note.id);
    }
    handleMenuClose();
  };

  const handleCardClick = () => {
    selectNote(note.id);
  };

  const formatDate = (date: Date) => {
    return formatDistanceToNow(new Date(date), {
      addSuffix: true,
      locale: ja
    });
  };

  return (
    <Card
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onClick={handleCardClick}
      sx={{
        height: note.size.height || 200,
        width: '100%',
        cursor: 'pointer',
        position: 'relative',
        background: colorConfig.background,
        border: `2px solid ${colorConfig.border}`,
        boxShadow: `0 4px 8px ${colorConfig.shadow}`,
        transition: 'all 0.3s ease',
        transform: isHovered ? 'translateY(-4px) rotate(1deg)' : 'rotate(0deg)',
        '&:hover': {
          boxShadow: `0 8px 16px ${colorConfig.shadow}`
        },
        ...(note.isCompleted && {
          opacity: 0.7,
          filter: 'grayscale(0.3)'
        })
      }}
    >
      {/* ãƒ‰ãƒ©ãƒƒã‚°ãƒãƒ³ãƒ‰ãƒ« */}
      <Fade in={isHovered}>
        <Box
          sx={{
            position: 'absolute',
            top: 8,
            left: 8,
            zIndex: 1
          }}
        >
          <DragIcon sx={{ color: 'action.active', fontSize: 16 }} />
        </Box>
      </Fade>

      {/* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ */}
      <Box
        sx={{
          position: 'absolute',
          top: 8,
          right: 8,
          zIndex: 2
        }}
      >
        <Fade in={isHovered}>
          <IconButton
            size="small"
            onClick={handleMenuClick}
            sx={{
              backgroundColor: 'rgba(255, 255, 255, 0.8)',
              '&:hover': {
                backgroundColor: 'rgba(255, 255, 255, 0.95)'
              }
            }}
          >
            <MoreIcon fontSize="small" />
          </IconButton>
        </Fade>
      </Box>

      {/* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ */}
      <Menu
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleMenuClose}
        onClick={(e) => e.stopPropagation()}
      >
        <MenuItem onClick={handleEdit}>
          <ListItemIcon>
            <EditIcon fontSize="small" />
          </ListItemIcon>
          ç·¨é›†
        </MenuItem>
        <MenuItem onClick={handleDelete}>
          <ListItemIcon>
            <DeleteIcon fontSize="small" />
          </ListItemIcon>
          å‰Šé™¤
        </MenuItem>
      </Menu>

      <CardContent sx={{ height: '100%', p: 2, position: 'relative' }}>
        {/* ã‚«ãƒ†ã‚´ãƒªãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ã¨å„ªå…ˆåº¦ */}
        <Box display="flex" justifyContent="space-between" alignItems="flex-start" mb={1}>
          <Typography variant="h6" component="div" sx={{ fontSize: '1.2rem' }}>
            {categoryIcon}
          </Typography>
          <Box
            sx={{
              width: 8,
              height: 8,
              borderRadius: '50%',
              backgroundColor: priorityColor
            }}
          />
        </Box>

        {/* ã‚¿ã‚¤ãƒˆãƒ« */}
        <Typography
          variant="h6"
          component="h3"
          sx={{
            fontWeight: 'bold',
            color: colorConfig.text,
            mb: 1,
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            display: '-webkit-box',
            WebkitLineClamp: 2,
            WebkitBoxOrient: 'vertical',
            ...(note.isCompleted && {
              textDecoration: 'line-through'
            })
          }}
        >
          {note.title}
        </Typography>

        {/* å†…å®¹ */}
        <Typography
          variant="body2"
          sx={{
            color: colorConfig.text,
            opacity: 0.8,
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            display: '-webkit-box',
            WebkitLineClamp: 3,
            WebkitBoxOrient: 'vertical',
            mb: 2
          }}
        >
          {note.content}
        </Typography>

        {/* ãƒ•ãƒƒã‚¿ãƒ¼æƒ…å ± */}
        <Box
          sx={{
            position: 'absolute',
            bottom: 8,
            left: 16,
            right: 16,
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center'
          }}
        >
          {/* ã‚¿ã‚° */}
          <Box display="flex" gap={0.5} flexWrap="wrap">
            {note.tags.slice(0, 2).map((tag, index) => (
              <Chip
                key={index}
                label={tag}
                size="small"
                sx={{
                  height: 18,
                  fontSize: '0.7rem',
                  backgroundColor: 'rgba(255, 255, 255, 0.7)'
                }}
              />
            ))}
            {note.tags.length > 2 && (
              <Chip
                label={`+${note.tags.length - 2}`}
                size="small"
                sx={{
                  height: 18,
                  fontSize: '0.7rem',
                  backgroundColor: 'rgba(255, 255, 255, 0.7)'
                }}
              />
            )}
          </Box>

          {/* æœŸé™ã¨æ›´æ–°æ—¥æ™‚ */}
          <Box display="flex" flexDirection="column" alignItems="flex-end">
            {note.dueDate && (
              <Tooltip title="æœŸé™">
                <Box display="flex" alignItems="center" gap={0.5}>
                  <ScheduleIcon sx={{ fontSize: 12, color: colorConfig.text }} />
                  <Typography
                    variant="caption"
                    sx={{
                      color: colorConfig.text,
                      fontSize: '0.7rem'
                    }}
                  >
                    {formatDate(note.dueDate)}
                  </Typography>
                </Box>
              </Tooltip>
            )}
            <Typography
              variant="caption"
              sx={{
                color: colorConfig.text,
                opacity: 0.6,
                fontSize: '0.65rem'
              }}
            >
              {formatDate(note.updatedAt)}
            </Typography>
          </Box>
        </Box>
      </CardContent>
    </Card>
  );
};
```

---

## ğŸ—ï¸ Step 4: ä»˜ç®‹ä½œæˆãƒ»ç·¨é›†ãƒ€ã‚¤ã‚¢ãƒ­ã‚°

### 4.1 ä»˜ç®‹ä½œæˆãƒ€ã‚¤ã‚¢ãƒ­ã‚°

```typescript
// components/StickyNotes/CreateNoteDialog.tsx
import React, { useState } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Button,
  Box,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Chip,
  Grid,
  Typography,
  IconButton
} from '@mui/material';
import {
  Close as CloseIcon,
  Add as AddIcon
} from '@mui/icons-material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { useStickyNotesStore } from '../../stores/useStickyNotesStore';
import { STICKY_COLORS, CATEGORY_ICONS } from '../../utils/stickyNoteColors';
import { StickyNote } from '../../types/stickyNote';

interface FormData {
  title: string;
  content: string;
  color: StickyNote['color'];
  category: StickyNote['category'];
  priority: StickyNote['priority'];
  tags: string[];
  dueDate?: Date;
}

export const CreateNoteDialog: React.FC = () => {
  const { isCreateDialogOpen, closeCreateDialog, addNote } = useStickyNotesStore();
  
  const [formData, setFormData] = useState<FormData>({
    title: '',
    content: '',
    color: 'yellow',
    category: 'normal',
    priority: 'medium',
    tags: [],
    dueDate: undefined
  });
  
  const [newTag, setNewTag] = useState('');
  const [errors, setErrors] = useState<Partial<FormData>>({});

  const handleClose = () => {
    setFormData({
      title: '',
      content: '',
      color: 'yellow',
      category: 'normal',
      priority: 'medium',
      tags: [],
      dueDate: undefined
    });
    setErrors({});
    setNewTag('');
    closeCreateDialog();
  };

  const handleInputChange = (field: keyof FormData) => (
    event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    setFormData(prev => ({
      ...prev,
      [field]: event.target.value
    }));
    
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: undefined }));
    }
  };

  const handleSelectChange = (field: keyof FormData) => (event: any) => {
    setFormData(prev => ({
      ...prev,
      [field]: event.target.value
    }));
  };

  const handleAddTag = () => {
    if (newTag.trim() && !formData.tags.includes(newTag.trim())) {
      setFormData(prev => ({
        ...prev,
        tags: [...prev.tags, newTag.trim()]
      }));
      setNewTag('');
    }
  };

  const handleRemoveTag = (tagToRemove: string) => {
    setFormData(prev => ({
      ...prev,
      tags: prev.tags.filter(tag => tag !== tagToRemove)
    }));
  };

  const handleKeyPress = (event: React.KeyboardEvent) => {
    if (event.key === 'Enter') {
      handleAddTag();
    }
  };

  const validateForm = (): boolean => {
    const newErrors: Partial<FormData> = {};
    
    if (!formData.title.trim()) {
      newErrors.title = 'ã‚¿ã‚¤ãƒˆãƒ«ã¯å¿…é ˆã§ã™';
    }
    
    if (!formData.content.trim()) {
      newErrors.content = 'å†…å®¹ã¯å¿…é ˆã§ã™';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = () => {
    if (!validateForm()) return;
    
    const newNote = {
      title: formData.title.trim(),
      content: formData.content.trim(),
      color: formData.color,
      category: formData.category,
      priority: formData.priority,
      tags: formData.tags,
      dueDate: formData.dueDate,
      position: {
        x: Math.random() * 100,
        y: Math.random() * 100
      },
      size: {
        width: 250,
        height: 200
      },
      isCompleted: false
    };
    
    addNote(newNote);
    handleClose();
  };

  return (
    <Dialog
      open={isCreateDialogOpen}
      onClose={handleClose}
      maxWidth="md"
      fullWidth
      PaperProps={{
        sx: {
          borderRadius: 2,
          maxHeight: '90vh'
        }
      }}
    >
      <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Typography variant="h6" component="div">
          ğŸ“ æ–°ã—ã„ä»˜ç®‹ã‚’ä½œæˆ
        </Typography>
        <IconButton onClick={handleClose} size="small">
          <CloseIcon />
        </IconButton>
      </DialogTitle>
      
      <DialogContent dividers>
        <Grid container spacing={3}>
          {/* ã‚¿ã‚¤ãƒˆãƒ« */}
          <Grid item xs={12}>
            <TextField
              label="ã‚¿ã‚¤ãƒˆãƒ«"
              value={formData.title}
              onChange={handleInputChange('title')}
              error={Boolean(errors.title)}
              helperText={errors.title}
              fullWidth
              required
            />
          </Grid>
          
          {/* å†…å®¹ */}
          <Grid item xs={12}>
            <TextField
              label="å†…å®¹"
              value={formData.content}
              onChange={handleInputChange('content')}
              error={Boolean(errors.content)}
              helperText={errors.content}
              fullWidth
              required
              multiline
              rows={4}
            />
          </Grid>
          
          {/* ã‚«ãƒ†ã‚´ãƒªãƒ¼ã¨å„ªå…ˆåº¦ */}
          <Grid item xs={12} sm={6}>
            <FormControl fullWidth>
              <InputLabel>ã‚«ãƒ†ã‚´ãƒªãƒ¼</InputLabel>
              <Select
                value={formData.category}
                onChange={handleSelectChange('category')}
                label="ã‚«ãƒ†ã‚´ãƒªãƒ¼"
              >
                {Object.entries(CATEGORY_ICONS).map(([category, icon]) => (
                  <MenuItem key={category} value={category}>
                    <Box display="flex" alignItems="center" gap={1}>
                      {icon}
                      <Typography>
                        {category === 'important' ? 'é‡è¦' :
                         category === 'normal' ? 'é€šå¸¸' :
                         category === 'completed' ? 'å®Œäº†' :
                         category === 'memo' ? 'ãƒ¡ãƒ¢' :
                         category === 'question' ? 'è³ªå•' : category}
                      </Typography>
                    </Box>
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>
          
          <Grid item xs={12} sm={6}>
            <FormControl fullWidth>
              <InputLabel>å„ªå…ˆåº¦</InputLabel>
              <Select
                value={formData.priority}
                onChange={handleSelectChange('priority')}
                label="å„ªå…ˆåº¦"
              >
                <MenuItem value="high">ğŸ”´ é«˜</MenuItem>
                <MenuItem value="medium">ğŸŸ¡ ä¸­</MenuItem>
                <MenuItem value="low">ğŸŸ¢ ä½</MenuItem>
              </Select>
            </FormControl>
          </Grid>
          
          {/* è‰²é¸æŠ */}
          <Grid item xs={12}>
            <Typography variant="subtitle2" gutterBottom>
              ä»˜ç®‹ã®è‰²
            </Typography>
            <Box display="flex" gap={1} flexWrap="wrap">
              {Object.entries(STICKY_COLORS).map(([color, colorConfig]) => (
                <Box
                  key={color}
                  onClick={() => setFormData(prev => ({ ...prev, color: color as any }))}
                  sx={{
                    width: 40,
                    height: 40,
                    borderRadius: 1,
                    background: colorConfig.background,
                    border: formData.color === color ? `3px solid ${colorConfig.border}` : `2px solid ${colorConfig.border}`,
                    cursor: 'pointer',
                    transition: 'all 0.2s ease',
                    '&:hover': {
                      transform: 'scale(1.1)'
                    }
                  }}
                />
              ))}
            </Box>
          </Grid>
          
          {/* ã‚¿ã‚° */}
          <Grid item xs={12}>
            <Typography variant="subtitle2" gutterBottom>
              ã‚¿ã‚°
            </Typography>
            <Box display="flex" gap={1} mb={1} flexWrap="wrap">
              {formData.tags.map((tag, index) => (
                <Chip
                  key={index}
                  label={tag}
                  onDelete={() => handleRemoveTag(tag)}
                  size="small"
                  color="primary"
                  variant="outlined"
                />
              ))}
            </Box>
            <Box display="flex" gap={1}>
              <TextField
                placeholder="æ–°ã—ã„ã‚¿ã‚°ã‚’å…¥åŠ›"
                value={newTag}
                onChange={(e) => setNewTag(e.target.value)}
                onKeyPress={handleKeyPress}
                size="small"
                sx={{ flexGrow: 1 }}
              />
              <Button
                onClick={handleAddTag}
                disabled={!newTag.trim()}
                startIcon={<AddIcon />}
                variant="outlined"
                size="small"
              >
                è¿½åŠ 
              </Button>
            </Box>
          </Grid>
          
          {/* æœŸé™ */}
          <Grid item xs={12}>
            <DatePicker
              label="æœŸé™ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰"
              value={formData.dueDate}
              onChange={(date) => setFormData(prev => ({ ...prev, dueDate: date || undefined }))}
              slotProps={{
                textField: {
                  fullWidth: true
                }
              }}
            />
          </Grid>
        </Grid>
      </DialogContent>
      
      <DialogActions sx={{ px: 3, py: 2 }}>
        <Button onClick={handleClose} color="inherit">
          ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        </Button>
        <Button
          onClick={handleSubmit}
          variant="contained"
          sx={{ minWidth: 100 }}
        >
          ä½œæˆ
        </Button>
      </DialogActions>
    </Dialog>
  );
};
```

### 4.2 ä»˜ç®‹ç·¨é›†ãƒ€ã‚¤ã‚¢ãƒ­ã‚°

```typescript
// components/StickyNotes/EditNoteDialog.tsx
import React, { useState, useEffect } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Button,
  Box,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Chip,
  Grid,
  Typography,
  IconButton,
  FormControlLabel,
  Checkbox
} from '@mui/material';
import {
  Close as CloseIcon,
  Add as AddIcon
} from '@mui/icons-material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { useStickyNotesStore } from '../../stores/useStickyNotesStore';
import { STICKY_COLORS, CATEGORY_ICONS } from '../../utils/stickyNoteColors';
import { StickyNote } from '../../types/stickyNote';

interface FormData {
  title: string;
  content: string;
  color: StickyNote['color'];
  category: StickyNote['category'];
  priority: StickyNote['priority'];
  tags: string[];
  dueDate?: Date;
  isCompleted: boolean;
}

export const EditNoteDialog: React.FC = () => {
  const { 
    isEditDialogOpen, 
    closeEditDialog, 
    updateNote, 
    selectedNoteId,
    notes 
  } = useStickyNotesStore();
  
  const selectedNote = notes.find(note => note.id === selectedNoteId);
  
  const [formData, setFormData] = useState<FormData>({
    title: '',
    content: '',
    color: 'yellow',
    category: 'normal',
    priority: 'medium',
    tags: [],
    dueDate: undefined,
    isCompleted: false
  });
  
  const [newTag, setNewTag] = useState('');
  const [errors, setErrors] = useState<Partial<FormData>>({});

  // é¸æŠã•ã‚ŒãŸä»˜ç®‹ã®æƒ…å ±ã‚’ãƒ•ã‚©ãƒ¼ãƒ ã«è¨­å®š
  useEffect(() => {
    if (selectedNote) {
      setFormData({
        title: selectedNote.title,
        content: selectedNote.content,
        color: selectedNote.color,
        category: selectedNote.category,
        priority: selectedNote.priority,
        tags: [...selectedNote.tags],
        dueDate: selectedNote.dueDate,
        isCompleted: selectedNote.isCompleted
      });
    }
  }, [selectedNote]);

  const handleClose = () => {
    setErrors({});
    setNewTag('');
    closeEditDialog();
  };

  const handleInputChange = (field: keyof FormData) => (
    event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    setFormData(prev => ({
      ...prev,
      [field]: event.target.value
    }));
    
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: undefined }));
    }
  };

  const handleSelectChange = (field: keyof FormData) => (event: any) => {
    setFormData(prev => ({
      ...prev,
      [field]: event.target.value
    }));
  };

  const handleCheckboxChange = (field: keyof FormData) => (
    event: React.ChangeEvent<HTMLInputElement>
  ) => {
    setFormData(prev => ({
      ...prev,
      [field]: event.target.checked
    }));
  };

  const handleAddTag = () => {
    if (newTag.trim() && !formData.tags.includes(newTag.trim())) {
      setFormData(prev => ({
        ...prev,
        tags: [...prev.tags, newTag.trim()]
      }));
      setNewTag('');
    }
  };

  const handleRemoveTag = (tagToRemove: string) => {
    setFormData(prev => ({
      ...prev,
      tags: prev.tags.filter(tag => tag !== tagToRemove)
    }));
  };

  const handleKeyPress = (event: React.KeyboardEvent) => {
    if (event.key === 'Enter') {
      handleAddTag();
    }
  };

  const validateForm = (): boolean => {
    const newErrors: Partial<FormData> = {};
    
    if (!formData.title.trim()) {
      newErrors.title = 'ã‚¿ã‚¤ãƒˆãƒ«ã¯å¿…é ˆã§ã™';
    }
    
    if (!formData.content.trim()) {
      newErrors.content = 'å†…å®¹ã¯å¿…é ˆã§ã™';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = () => {
    if (!validateForm() || !selectedNoteId) return;
    
    const updates = {
      title: formData.title.trim(),
      content: formData.content.trim(),
      color: formData.color,
      category: formData.category,
      priority: formData.priority,
      tags: formData.tags,
      dueDate: formData.dueDate,
      isCompleted: formData.isCompleted
    };
    
    updateNote(selectedNoteId, updates);
    handleClose();
  };

  if (!selectedNote) {
    return null;
  }

  return (
    <Dialog
      open={isEditDialogOpen}
      onClose={handleClose}
      maxWidth="md"
      fullWidth
      PaperProps={{
        sx: {
          borderRadius: 2,
          maxHeight: '90vh'
        }
      }}
    >
      <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Typography variant="h6" component="div">
          âœï¸ ä»˜ç®‹ã‚’ç·¨é›†
        </Typography>
        <IconButton onClick={handleClose} size="small">
          <CloseIcon />
        </IconButton>
      </DialogTitle>
      
      <DialogContent dividers>
        <Grid container spacing={3}>
          {/* å®Œäº†ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ */}
          <Grid item xs={12}>
            <FormControlLabel
              control={
                <Checkbox
                  checked={formData.isCompleted}
                  onChange={handleCheckboxChange('isCompleted')}
                  color="success"
                />
              }
              label="å®Œäº†æ¸ˆã¿"
            />
          </Grid>
          
          {/* ã‚¿ã‚¤ãƒˆãƒ« */}
          <Grid item xs={12}>
            <TextField
              label="ã‚¿ã‚¤ãƒˆãƒ«"
              value={formData.title}
              onChange={handleInputChange('title')}
              error={Boolean(errors.title)}
              helperText={errors.title}
              fullWidth
              required
            />
          </Grid>
          
          {/* å†…å®¹ */}
          <Grid item xs={12}>
            <TextField
              label="å†…å®¹"
              value={formData.content}
              onChange={handleInputChange('content')}
              error={Boolean(errors.content)}
              helperText={errors.content}
              fullWidth
              required
              multiline
              rows={4}
            />
          </Grid>
          
          {/* ã‚«ãƒ†ã‚´ãƒªãƒ¼ã¨å„ªå…ˆåº¦ */}
          <Grid item xs={12} sm={6}>
            <FormControl fullWidth>
              <InputLabel>ã‚«ãƒ†ã‚´ãƒªãƒ¼</InputLabel>
              <Select
                value={formData.category}
                onChange={handleSelectChange('category')}
                label="ã‚«ãƒ†ã‚´ãƒªãƒ¼"
              >
                {Object.entries(CATEGORY_ICONS).map(([category, icon]) => (
                  <MenuItem key={category} value={category}>
                    <Box display="flex" alignItems="center" gap={1}>
                      {icon}
                      <Typography>
                        {category === 'important' ? 'é‡è¦' :
                         category === 'normal' ? 'é€šå¸¸' :
                         category === 'completed' ? 'å®Œäº†' :
                         category === 'memo' ? 'ãƒ¡ãƒ¢' :
                         category === 'question' ? 'è³ªå•' : category}
                      </Typography>
                    </Box>
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>
          
          <Grid item xs={12} sm={6}>
            <FormControl fullWidth>
              <InputLabel>å„ªå…ˆåº¦</InputLabel>
              <Select
                value={formData.priority}
                onChange={handleSelectChange('priority')}
                label="å„ªå…ˆåº¦"
              >
                <MenuItem value="high">ğŸ”´ é«˜</MenuItem>
                <MenuItem value="medium">ğŸŸ¡ ä¸­</MenuItem>
                <MenuItem value="low">ğŸŸ¢ ä½</MenuItem>
              </Select>
            </FormControl>
          </Grid>
          
          {/* è‰²é¸æŠ */}
          <Grid item xs={12}>
            <Typography variant="subtitle2" gutterBottom>
              ä»˜ç®‹ã®è‰²
            </Typography>
            <Box display="flex" gap={1} flexWrap="wrap">
              {Object.entries(STICKY_COLORS).map(([color, colorConfig]) => (
                <Box
                  key={color}
                  onClick={() => setFormData(prev => ({ ...prev, color: color as any }))}
                  sx={{
                    width: 40,
                    height: 40,
                    borderRadius: 1,
                    background: colorConfig.background,
                    border: formData.color === color ? `3px solid ${colorConfig.border}` : `2px solid ${colorConfig.border}`,
                    cursor: 'pointer',
                    transition: 'all 0.2s ease',
                    '&:hover': {
                      transform: 'scale(1.1)'
                    }
                  }}
                />
              ))}
            </Box>
          </Grid>
          
          {/* ã‚¿ã‚° */}
          <Grid item xs={12}>
            <Typography variant="subtitle2" gutterBottom>
              ã‚¿ã‚°
            </Typography>
            <Box display="flex" gap={1} mb={1} flexWrap="wrap">
              {formData.tags.map((tag, index) => (
                <Chip
                  key={index}
                  label={tag}
                  onDelete={() => handleRemoveTag(tag)}
                  size="small"
                  color="primary"
                  variant="outlined"
                />
              ))}
            </Box>
            <Box display="flex" gap={1}>
              <TextField
                placeholder="æ–°ã—ã„ã‚¿ã‚°ã‚’å…¥åŠ›"
                value={newTag}
                onChange={(e) => setNewTag(e.target.value)}
                onKeyPress={handleKeyPress}
                size="small"
                sx={{ flexGrow: 1 }}
              />
              <Button
                onClick={handleAddTag}
                disabled={!newTag.trim()}
                startIcon={<AddIcon />}
                variant="outlined"
                size="small"
              >
                è¿½åŠ 
              </Button>
            </Box>
          </Grid>
          
          {/* æœŸé™ */}
          <Grid item xs={12}>
            <DatePicker
              label="æœŸé™ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰"
              value={formData.dueDate}
              onChange={(date) => setFormData(prev => ({ ...prev, dueDate: date || undefined }))}
              slotProps={{
                textField: {
                  fullWidth: true
                }
              }}
            />
          </Grid>
        </Grid>
      </DialogContent>
      
      <DialogActions sx={{ px: 3, py: 2 }}>
        <Button onClick={handleClose} color="inherit">
          ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        </Button>
        <Button
          onClick={handleSubmit}
          variant="contained"
          sx={{ minWidth: 100 }}
        >
          æ›´æ–°
        </Button>
      </DialogActions>
    </Dialog>
  );
};
```

---

## ğŸ—ï¸ Step 5: ç©ºçŠ¶æ…‹ã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

### 5.1 ç©ºçŠ¶æ…‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```typescript
// components/StickyNotes/EmptyState.tsx
import React from 'react';
import {
  Box,
  Typography,
  Button,
  Paper
} from '@mui/material';
import {
  NoteAdd as NoteAddIcon,
  Search as SearchIcon
} from '@mui/icons-material';
import { useStickyNotesStore } from '../../stores/useStickyNotesStore';
import { CATEGORY_ICONS } from '../../utils/stickyNoteColors';

interface EmptyStateProps {
  message: string;
  category?: string;
}

export const EmptyState: React.FC<EmptyStateProps> = ({ message, category }) => {
  const { openCreateDialog, clearFilter, filter } = useStickyNotesStore();
  
  const hasFilters = Boolean(
    filter.searchQuery || filter.color || filter.priority
  );
  
  const categoryIcon = category ? CATEGORY_ICONS[category] : 'ğŸ“‹';
  const categoryName = category ? {
    important: 'é‡è¦',
    normal: 'é€šå¸¸',
    completed: 'å®Œäº†',
    memo: 'ãƒ¡ãƒ¢',
    question: 'è³ªå•'
  }[category] || category : '';

  return (
    <Box
      display="flex"
      flexDirection="column"
      alignItems="center"
      justifyContent="center"
      height="100%"
      minHeight={400}
      sx={{ textAlign: 'center' }}
    >
      <Paper
        elevation={0}
        sx={{
          p: 4,
          backgroundColor: 'grey.50',
          borderRadius: 2,
          maxWidth: 400
        }}
      >
        {/* ã‚¢ã‚¤ã‚³ãƒ³ */}
        <Box mb={2}>
          <Typography
            sx={{
              fontSize: '4rem',
              filter: 'grayscale(0.3)',
              opacity: 0.7
            }}
          >
            {hasFilters ? 'ğŸ”' : categoryIcon}
          </Typography>
        </Box>
        
        {/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */}
        <Typography
          variant="h6"
          component="h3"
          gutterBottom
          sx={{ color: 'text.secondary' }}
        >
          {hasFilters ? 'æ¤œç´¢çµæœãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' : message}
        </Typography>
        
        <Typography
          variant="body2"
          sx={{ color: 'text.secondary', mb: 3 }}
        >
          {hasFilters 
            ? 'æ¤œç´¢æ¡ä»¶ã‚’å¤‰æ›´ã—ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„'
            : category 
              ? `${categoryName}ã‚«ãƒ†ã‚´ãƒªã®ä»˜ç®‹ã‚’ä½œæˆã—ã¦ã€ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’æ•´ç†ã—ã¾ã—ã‚‡ã†`
              : 'æ–°ã—ã„ä»˜ç®‹ã‚’ä½œæˆã—ã¦ã€ã‚¢ã‚¤ãƒ‡ã‚¢ã‚„ã‚¿ã‚¹ã‚¯ã‚’æ•´ç†ã—ã¾ã—ã‚‡ã†'
          }
        </Typography>
        
        {/* ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ */}
        <Box display="flex" gap={2} justifyContent="center">
          {hasFilters ? (
            <Button
              variant="outlined"
              onClick={clearFilter}
              startIcon={<SearchIcon />}
            >
              ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’ã‚¯ãƒªã‚¢
            </Button>
          ) : (
            <Button
              variant="contained"
              onClick={openCreateDialog}
              startIcon={<NoteAddIcon />}
              sx={{
                borderRadius: 2,
                textTransform: 'none',
                fontWeight: 'bold'
              }}
            >
              æœ€åˆã®ä»˜ç®‹ã‚’ä½œæˆ
            </Button>
          )}
        </Box>
      </Paper>
    </Box>
  );
};
```

---

## ğŸ—ï¸ Step 6: ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½ï¼ˆä¸Šç´šï¼‰

### 6.1 ãƒ‰ãƒ©ãƒƒã‚°å¯¾å¿œä»˜ç®‹ã‚«ãƒ¼ãƒ‰

```typescript
// components/StickyNotes/DraggableStickyNote.tsx
import React, { useRef, useState } from 'react';
import { useDrag, useDrop } from 'react-dnd';
import { StickyNoteCard } from './StickyNoteCard';
import { StickyNote } from '../../types/stickyNote';
import { useStickyNotesStore } from '../../stores/useStickyNotesStore';

interface DraggableStickyNoteProps {
  note: StickyNote;
  onMove?: (draggedId: string, hoveredId: string) => void;
}

export const DraggableStickyNote: React.FC<DraggableStickyNoteProps> = ({ 
  note, 
  onMove 
}) => {
  const ref = useRef<HTMLDivElement>(null);
  const { moveNote } = useStickyNotesStore();
  
  const [{ isDragging }, drag] = useDrag({
    type: 'sticky-note',
    item: { id: note.id, type: 'sticky-note' },
    collect: (monitor) => ({
      isDragging: monitor.isDragging()
    })
  });
  
  const [, drop] = useDrop({
    accept: 'sticky-note',
    hover: (draggedItem: { id: string }) => {
      if (draggedItem.id !== note.id && onMove) {
        onMove(draggedItem.id, note.id);
      }
    }
  });
  
  drag(drop(ref));
  
  return (
    <div
      ref={ref}
      style={{
        opacity: isDragging ? 0.5 : 1,
        cursor: isDragging ? 'grabbing' : 'grab'
      }}
    >
      <StickyNoteCard note={note} />
    </div>
  );
};
```

---

## ğŸ† ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ãƒãƒ£ãƒ¬ãƒ³ã‚¸

### åˆç´šï¼ˆâ­ï¼‰
1. åŸºæœ¬çš„ãªä»˜ç®‹ä½œæˆãƒ»è¡¨ç¤ºæ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã‚ˆã†
2. ã‚«ãƒ†ã‚´ãƒªåˆ¥ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’è¿½åŠ ã—ã‚ˆã†

### ä¸­ç´šï¼ˆâ­â­ï¼‰
1. ä»˜ç®‹ã®ç·¨é›†ãƒ»å‰Šé™¤æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã‚ˆã†
2. ã‚¿ã‚°æ©Ÿèƒ½ã¨æ¤œç´¢æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã‚ˆã†
3. æœŸé™è¡¨ç¤ºã¨ã‚¢ãƒ©ãƒ¼ãƒˆæ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã‚ˆã†

### ä¸Šç´šï¼ˆâ­â­â­ï¼‰
1. ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã«ã‚ˆã‚‹ä¸¦ã³æ›¿ãˆæ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã‚ˆã†
2. ä»˜ç®‹ã®ã‚µã‚¤ã‚ºå¤‰æ›´æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã‚ˆã†
3. ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ»ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã‚ˆã†
4. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸæ©Ÿèƒ½ã‚’æ¤œè¨ã—ã‚ˆã†

---

## ğŸ¨ CSS ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã®ãƒ’ãƒ³ãƒˆ

### ä»˜ç®‹é¢¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

```css
/* ä»˜ç®‹ã®å½±åŠ¹æœ */
.sticky-note {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  transform-origin: center center;
}

.sticky-note:hover {
  transform: translateY(-8px) rotate(2deg) scale(1.02);
  box-shadow: 0 16px 32px rgba(0, 0, 0, 0.2);
}

/* ãƒšãƒ©ãƒšãƒ©åŠ¹æœ */
.sticky-note::before {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  width: 20px;
  height: 20px;
  background: linear-gradient(
    135deg,
    transparent 50%,
    rgba(0, 0, 0, 0.1) 50%
  );
  clip-path: polygon(0 0, 100% 0, 100% 100%);
}

/* ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.sticky-note-enter {
  animation: fadeInUp 0.4s ease-out;
}
```

---

## ğŸ“š ã¾ã¨ã‚

ä»˜ç®‹æ©Ÿèƒ½ã®å®Ÿè£…ã«ã‚ˆã‚Šã€ä»¥ä¸‹ã®ã‚¹ã‚­ãƒ«ã‚’ç¿’å¾—ã§ãã¾ã™ï¼š

### æŠ€è¡“çš„ã‚¹ã‚­ãƒ«
- âœ… **çŠ¶æ…‹ç®¡ç†**ï¼šZustandã«ã‚ˆã‚‹è¤‡é›‘ãªçŠ¶æ…‹ç®¡ç†
- âœ… **UI/UXè¨­è¨ˆ**ï¼šç›´æ„Ÿçš„ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹è¨­è¨ˆ
- âœ… **ãƒ•ã‚©ãƒ¼ãƒ å‡¦ç†**ï¼šãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ããƒ•ã‚©ãƒ¼ãƒ 
- âœ… **ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ **ï¼šã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®é©åˆ‡ãªåˆ†å‰²
- âœ… **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**ï¼šæœ€é©åŒ–ã•ã‚ŒãŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°

### å®Ÿè·µçš„ã‚¹ã‚­ãƒ«
- âœ… **ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—**ï¼šreact-dnd ã«ã‚ˆã‚‹æ“ä½œæ€§å‘ä¸Š
- âœ… **æ¤œç´¢ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°**ï¼šãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ã®å‘ä¸Š
- âœ… **ãƒ‡ãƒ¼ã‚¿ã®æ°¸ç¶šåŒ–**ï¼šlocalStorageã¨ã®é€£æº
- âœ… **ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ**ï¼šã‚ã‚‰ã‚†ã‚‹ãƒ‡ãƒã‚¤ã‚¹ã§å¿«é©

ä»˜ç®‹æ©Ÿèƒ½ã¯è¦‹ãŸç›®ä»¥ä¸Šã«å¥¥ãŒæ·±ãã€å®Ÿè£…ã‚’é€šã˜ã¦Reactã®æ§˜ã€…ãªæ¦‚å¿µã‚’å­¦ã¶ã“ã¨ãŒã§ãã¾ã™ï¼

---

## ğŸ”— æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

- TasQ Flowã®ä»–ã®æ©Ÿèƒ½ã¨é€£æºã—ã¦ã¿ã‚ˆã†
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã¦ã¿ã‚ˆã†  
- ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œã‚’å¼·åŒ–ã—ã¦ã¿ã‚ˆã†
- ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã‚’å‘ä¸Šã•ã›ã¦ã¿ã‚ˆã†

## ğŸ’¡ å‚è€ƒãƒªã‚½ãƒ¼ã‚¹

- [Material-UI Grid System](https://mui.com/system/grid/)
- [React DnD](https://react-dnd.github.io/react-dnd/)
- [Zustand Best Practices](https://zustand-demo.pmnd.rs/)
- [React Hook Form](https://react-hook-form.com/)
- [Date-fns Formatting](https://date-fns.org/docs/Getting-Started)