import React, { useState, useCallback } from 'react';
import {
  Box,
  Typography,
  Button,
  ButtonGroup,
  LinearProgress,
  Chip,
  Alert,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Divider,
  IconButton,
  Collapse,
} from '@mui/material';
import Grid from '@mui/material/Grid';
import {
  PlayArrow as StartIcon,
  Stop as StopIcon,
  RestartAlt as ResetIcon,
  ExpandMore as ExpandIcon,
  ExpandLess as CollapseIcon,
  Speed as SpeedIcon,
  Assessment as ReportIcon,
  GetApp as ExportIcon,
} from '@mui/icons-material';
import { 
  runPerformanceTest, 
  performanceTestScenarios,
  measureMemoryUsage
} from '../../data/performanceTestData';
import { useAppStore } from '../../stores/useAppStore';
import { performanceTestRunner } from '../../utils/performanceTestRunner';
import { 
  StyledCard, 
  SectionHeader, 
  PrimaryActionButton, 
  SecondaryActionButton,
  StatusChip 
} from '../../styles/commonStyles';

interface PerformanceMetrics {
  renderTime: number;
  updateTime: number;
  scrollFPS: number;
  memoryUsage: ReturnType<typeof measureMemoryUsage>;
  taskCount: number;
  visibleElements: number;
  canvasDrawCalls: number;
}

interface TestResult {
  scenario: keyof typeof performanceTestScenarios;
  metrics: PerformanceMetrics;
  timestamp: Date;
  duration: number;
}

export const PerformanceTestPanel: React.FC = () => {
  const [isRunning, setIsRunning] = useState(false);
  const [currentScenario, setCurrentScenario] = useState<keyof typeof performanceTestScenarios>('small');
  const [progress, setProgress] = useState(0);
  const [results, setResults] = useState<TestResult[]>([]);
  const [showDetails, setShowDetails] = useState(false);
  const [currentMetrics, setCurrentMetrics] = useState<PerformanceMetrics | null>(null);
  
  const { setTasks, setMembers, tasks } = useAppStore();
  
  // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞
  React.useEffect(() => {
    console.log('üîß PerformanceTestPanel mounted');
    console.log('Available scenarios:', Object.keys(performanceTestScenarios));
    console.log('Performance test runner available:', !!performanceTestRunner);
  }, []);
  
  // FPSÊ∏¨ÂÆö (unused)
  // const measureFPS = useCallback(() => { ... }, [isRunning]);
  
  // „É¨„É≥„ÉÄ„É™„É≥„Ç∞ÊôÇÈñì„ÅÆÊ∏¨ÂÆö (unused)
  // const measureRenderTime = useCallback(async () => { ... }, []);
  
  // „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà„ÅÆÂÆüË°å
  const runTest = useCallback(async (scenario: keyof typeof performanceTestScenarios) => {
    console.log('üöÄ Starting performance test:', scenario);
    setIsRunning(true);
    setProgress(0);
    
    const testStartTime = performance.now();
    
    try {
      // „Éá„Éº„ÇøÁîüÊàê
      setProgress(10);
      console.log('üìä Generating test data for scenario:', scenario);
      const data = runPerformanceTest(scenario);
      console.log('‚úÖ Data generated:', { 
        tasks: data.tasks.length, 
        members: data.members.length,
        events: data.events.length 
      });
      
      // „Éá„Éº„ÇøÈÅ©Áî®
      setProgress(30);
      console.log('üîÑ Applying data to store...');
      setTasks(data.tasks);
      setMembers(data.members);
      console.log('‚úÖ Data applied to store');
      
      // „É¨„É≥„ÉÄ„É™„É≥„Ç∞ÂæÖÊ©ü
      setProgress(50);
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // ÂÆüÈöõ„ÅÆ„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊ∏¨ÂÆö
      setProgress(70);
      console.log('üìà Running browser performance test...');
      const browserResult = await performanceTestRunner.runTest(
        scenario,
        data.tasks.length,
        (progress) => setProgress(70 + (progress * 0.2)) // 70-90%
      );
      console.log('‚úÖ Browser performance test completed:', browserResult);
      
      // ÂæìÊù•„ÅÆ„É°„Éà„É™„ÇØ„Çπ„ÇÇÊ∏¨ÂÆö
      const memoryUsage = measureMemoryUsage();
      const visibleElements = document.querySelectorAll('[data-testid]').length;
      const allElements = document.querySelectorAll('*').length;
      
      // ÁµêÊûúË®òÈå≤
      const metrics: PerformanceMetrics = {
        renderTime: browserResult.renderTime,
        updateTime: 0,
        scrollFPS: browserResult.fps,
        memoryUsage,
        taskCount: data.tasks.length,
        visibleElements: visibleElements || allElements,
        canvasDrawCalls: document.querySelectorAll('canvas').length * browserResult.fps,
      };
      
      setCurrentMetrics(metrics);
      
      const result: TestResult = {
        scenario,
        metrics,
        timestamp: new Date(),
        duration: performance.now() - testStartTime,
      };
      
      setResults(prev => [...prev, result]);
      setProgress(100);
      
      // ÂÆå‰∫ÜÂæå„ÅÆÂæÖÊ©ü
      await new Promise(resolve => setTimeout(resolve, 500));
      
    } catch (error) {
      console.error('‚ùå Performance test failed:', error);
      console.error('Error stack:', error instanceof Error ? error.stack : 'No stack trace');
    } finally {
      console.log('üèÅ Performance test finished');
      setIsRunning(false);
      setProgress(0);
    }
  }, [setTasks, setMembers]);
  
  // Ëá™Âãï„Çπ„ÇØ„É≠„Éº„É´„ÉÜ„Çπ„Éà
  const runScrollTest = useCallback(async () => {
    if (tasks.length === 0) {
      console.warn('„Çπ„ÇØ„É≠„Éº„É´„ÉÜ„Çπ„Éà„ÇíÂÆüË°å„Åô„Çã„Å´„ÅØ„ÄÅ„Åæ„Åö„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
      return;
    }
    
    try {
      // „Ç¨„É≥„Éà„ÉÅ„É£„Éº„Éà„Ç≥„É≥„ÉÜ„Éä„ÇíÊé¢„Åô
      const ganttContainer = document.querySelector('[data-testid="gantt-container"]') ||
                            document.querySelector('.gantt-container') ||
                            document.querySelector('[class*="gantt"]');
      
      if (!ganttContainer) {
        console.warn('Gantt container not found. Available containers:', 
                    Array.from(document.querySelectorAll('[data-testid]')).map(el => el.getAttribute('data-testid')));
        return;
      }
      
      const scrollResult = await performanceTestRunner.runScrollTest(
        ganttContainer.tagName.toLowerCase() + (ganttContainer.className ? '.' + ganttContainer.className.split(' ')[0] : '')
      );
      
      console.log('Scroll Test Results:', scrollResult);
      
      // ÁèæÂú®„ÅÆ„É°„Éà„É™„ÇØ„Çπ„ÇíÊõ¥Êñ∞
      if (currentMetrics) {
        const updatedMetrics: PerformanceMetrics = {
          ...currentMetrics,
          scrollFPS: scrollResult.fps,
          updateTime: scrollResult.smoothness * 100
        };
        setCurrentMetrics(updatedMetrics);
      }
      
    } catch (error) {
      console.error('Scroll test failed:', error);
    }
  }, [tasks.length, currentMetrics]);
  
  // „É°„Éà„É™„ÇØ„Çπ„ÅÆË°®Á§∫
  const renderMetrics = (metrics: PerformanceMetrics) => (
    <TableContainer>
      <Table size="small">
        <TableBody>
          <TableRow>
            <TableCell>„É¨„É≥„ÉÄ„É™„É≥„Ç∞ÊôÇÈñì</TableCell>
            <TableCell align="right">
              <Chip 
                label={`${metrics.renderTime.toFixed(2)} ms`}
                color={metrics.renderTime < 100 ? 'success' : metrics.renderTime < 200 ? 'warning' : 'error'}
                size="small"
              />
            </TableCell>
          </TableRow>
          <TableRow>
            <TableCell>„Çø„Çπ„ÇØÊï∞</TableCell>
            <TableCell align="right">{metrics.taskCount.toLocaleString()}</TableCell>
          </TableRow>
          <TableRow>
            <TableCell>DOMË¶ÅÁ¥†Êï∞</TableCell>
            <TableCell align="right">{metrics.visibleElements.toLocaleString()}</TableCell>
          </TableRow>
          <TableRow>
            <TableCell>Êé®ÂÆöFPS</TableCell>
            <TableCell align="right">
              <Chip 
                label={`${metrics.scrollFPS} fps`}
                color={metrics.scrollFPS >= 50 ? 'success' : metrics.scrollFPS >= 30 ? 'warning' : 'error'}
                size="small"
              />
            </TableCell>
          </TableRow>
          {metrics.memoryUsage && (
            <>
              <TableRow>
                <TableCell>‰ΩøÁî®„É°„É¢„É™</TableCell>
                <TableCell align="right">{metrics.memoryUsage.usedJSHeapSize}</TableCell>
              </TableRow>
              <TableRow>
                <TableCell>Á∑è„É°„É¢„É™</TableCell>
                <TableCell align="right">{metrics.memoryUsage.totalJSHeapSize}</TableCell>
              </TableRow>
            </>
          )}
        </TableBody>
      </Table>
    </TableContainer>
  );
  
  return (
    <StyledCard sx={{ m: 2 }}>
      <SectionHeader>
        <Typography variant="h5" component="h2" sx={{ display: 'flex', alignItems: 'center' }}>
          <SpeedIcon sx={{ mr: 1, color: 'primary.main' }} />
          üöÄ „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà
        </Typography>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          {isRunning && <StatusChip status="warning">ÂÆüË°å‰∏≠</StatusChip>}
          <IconButton onClick={() => setShowDetails(!showDetails)}>
            {showDetails ? <CollapseIcon /> : <ExpandIcon />}
          </IconButton>
        </Box>
      </SectionHeader>
      
      <Grid container spacing={3}>
        <Grid size={{ xs: 12, md: 6 }}>
          <Typography variant="subtitle2" gutterBottom>
            „ÉÜ„Çπ„Éà„Ç∑„Éä„É™„Ç™
          </Typography>
          <ButtonGroup fullWidth variant="outlined" sx={{ mb: 2 }}>
            {Object.keys(performanceTestScenarios).map((scenario) => (
              <Button
                key={scenario}
                variant={currentScenario === scenario ? 'contained' : 'outlined'}
                onClick={() => setCurrentScenario(scenario as keyof typeof performanceTestScenarios)}
                disabled={isRunning}
              >
                {scenario}
              </Button>
            ))}
          </ButtonGroup>
          
          <Box sx={{ mb: 2 }}>
            {currentScenario && (
              <Alert severity="info">
                <Typography variant="body2">
                  <strong>{currentScenario}„Ç∑„Éä„É™„Ç™:</strong>
                  {' '}
                  {performanceTestScenarios[currentScenario].tasks}„Çø„Çπ„ÇØ„ÄÅ
                  {performanceTestScenarios[currentScenario].members}„É°„É≥„Éê„Éº„ÄÅ
                  {performanceTestScenarios[currentScenario].events}„Ç§„Éô„É≥„Éà
                </Typography>
              </Alert>
            )}
          </Box>
          
          <Box sx={{ display: 'flex', gap: 1, mb: 2, flexWrap: 'wrap' }}>
            <PrimaryActionButton
              color="primary"
              startIcon={isRunning ? <StopIcon /> : <StartIcon />}
              onClick={() => isRunning ? setIsRunning(false) : runTest(currentScenario)}
              disabled={isRunning && progress > 0 && progress < 100}
            >
              {isRunning ? '„ÉÜ„Çπ„ÉàÂÅúÊ≠¢' : '„ÉÜ„Çπ„ÉàÈñãÂßã'}
            </PrimaryActionButton>
            
            <SecondaryActionButton
              startIcon={<ResetIcon />}
              onClick={() => {
                setTasks([]);
                setMembers([]);
                setCurrentMetrics(null);
                setResults([]);
                performanceTestRunner.clearResults();
              }}
              disabled={isRunning}
            >
              „É™„Çª„ÉÉ„Éà
            </SecondaryActionButton>
            
            <SecondaryActionButton
              startIcon={<ExportIcon />}
              onClick={() => {
                const exportData = performanceTestRunner.exportResults();
                const blob = new Blob([exportData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `performance-test-results-${new Date().getTime()}.json`;
                a.click();
                URL.revokeObjectURL(url);
              }}
              disabled={results.length === 0}
            >
              ÁµêÊûú„Ç®„ÇØ„Çπ„Éù„Éº„Éà
            </SecondaryActionButton>
            
            <SecondaryActionButton
              onClick={runScrollTest}
              disabled={tasks.length === 0}
            >
              „Çπ„ÇØ„É≠„Éº„É´„ÉÜ„Çπ„Éà
            </SecondaryActionButton>
          </Box>
          
          {isRunning && progress > 0 && (
            <Box sx={{ mb: 2 }}>
              <LinearProgress variant="determinate" value={progress} />
              <Typography variant="caption" color="text.secondary">
                {progress}% ÂÆå‰∫Ü
              </Typography>
            </Box>
          )}
        </Grid>
        
        <Grid size={{ xs: 12, md: 6 }}>
          <Typography variant="subtitle2" gutterBottom>
            ÁèæÂú®„ÅÆ„É°„Éà„É™„ÇØ„Çπ
          </Typography>
          {currentMetrics ? (
            renderMetrics(currentMetrics)
          ) : (
            <Alert severity="info">
              „ÉÜ„Çπ„Éà„ÇíÂÆüË°å„Åó„Å¶„É°„Éà„É™„ÇØ„Çπ„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ
            </Alert>
          )}
        </Grid>
      </Grid>
      
      <Collapse in={showDetails}>
        <Divider sx={{ my: 3 }} />
        
        <Typography variant="h6" gutterBottom>
          <ReportIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
          „ÉÜ„Çπ„ÉàÂ±•Ê≠¥
        </Typography>
        
        {results.length > 0 ? (
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>„Ç∑„Éä„É™„Ç™</TableCell>
                  <TableCell>„Çø„Çπ„ÇØÊï∞</TableCell>
                  <TableCell>„É¨„É≥„ÉÄ„É™„É≥„Ç∞ÊôÇÈñì</TableCell>
                  <TableCell>FPS</TableCell>
                  <TableCell>ÂÆüË°åÊôÇÈñì</TableCell>
                  <TableCell>ÂÆüË°åÊó•ÊôÇ</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {results.map((result, index) => (
                  <TableRow key={index}>
                    <TableCell>{result.scenario}</TableCell>
                    <TableCell>{result.metrics.taskCount.toLocaleString()}</TableCell>
                    <TableCell>
                      <Chip 
                        label={`${result.metrics.renderTime.toFixed(2)} ms`}
                        size="small"
                        color={result.metrics.renderTime < 100 ? 'success' : 'warning'}
                      />
                    </TableCell>
                    <TableCell>{result.metrics.scrollFPS} fps</TableCell>
                    <TableCell>{(result.duration / 1000).toFixed(2)} Áßí</TableCell>
                    <TableCell>{result.timestamp.toLocaleTimeString()}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        ) : (
          <Alert severity="info">
            „Åæ„Å†„ÉÜ„Çπ„ÉàÁµêÊûú„Åå„ÅÇ„Çä„Åæ„Åõ„Çì
          </Alert>
        )}
      </Collapse>
    </StyledCard>
  );
};